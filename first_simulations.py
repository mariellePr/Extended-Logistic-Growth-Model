# -*- coding: utf-8 -*-
"""Untitled41.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DlK-QOGhbZZaBEfxpOFObVubhyTYkojH
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import curve_fit

# Define the integro-differential equation model
def integro_differential_model(t, y, a, b, m):
    x = y[0]  # Current value of x
    integral = y[1]  # Current value of the integral
    dx_dt = a * x * np.exp(-b * integral) - m * x
    dintegral_dt = x  # The derivative of the integral is simply x
    return [dx_dt, dintegral_dt]

# Define a function to solve the integro-differential equation
def solve_model(t_eval, a, b, m, x0, integral0):
    t_span = (t_eval[0], t_eval[-1])
    y0 = [x0, integral0]  # Initial conditions: [x, integral]

    sol = solve_ivp(
        lambda t, y: integro_differential_model(t, y, a, b, m),
        t_span,
        y0,
        t_eval=t_eval,
        method='RK45'
    )
    return sol.y[0]  # Return only the population (x)

# Data for T=30
data_time_30 = np.array([0, 3, 6, 9, 12, 24, 27, 30, 33, 36, 48])
data_x_30 = np.array([0.36, 0.59, 0.85, 1.44, 2.60, 8.54, 10.82, 12.46, 14.81, 14.29, 10.47])

# Data for T=25
data_time_25 = np.array([0, 3, 6, 9, 12, 24, 27, 30, 33, 36, 48])
data_x_25 = np.array([0.35, 0.47, 0.88, 1.30, 2.29, 7.03, 10.62, 12.70, 14.33, 14.17, 11.49])

# Define a function for curve fitting
def fit_model(t, a, b, m, x0):
    return solve_model(t, a, b, m, x0=x0, integral0=0.0)

# Fit the model to T=30 data
popt_30, pcov_30 = curve_fit(
    lambda t, a, b, m, x0: fit_model(t, a, b, m, x0),
    data_time_30,
    data_x_30,
    p0=[0.4, 0.02, 0.01, 0.36],  # Initial guess for a, b, m, x0
    bounds=(0, [2, 1, 1, 1])  # Bounds for a, b, m, x0
)

# Fit the model to T=25 data
popt_25, pcov_25 = curve_fit(
    lambda t, a, b, m, x0: fit_model(t, a, b, m, x0),
    data_time_25,
    data_x_25,
    p0=[0.4, 0.02, 0.01, 0.35],  # Initial guess for a, b, m, x0
    bounds=(0, [2, 1, 1, 1])  # Bounds for a, b, m, x0
)

# Extract fitted parameters for T=30 and T=25
a_fit_30, b_fit_30, m_fit_30, x0_fit_30 = popt_30
a_fit_25, b_fit_25, m_fit_25, x0_fit_25 = popt_25

# Solve the model with fitted parameters
t_fine = np.linspace(0, 48, 500)
x_fit_30 = solve_model(t_fine, a_fit_30, b_fit_30, m_fit_30, x0=x0_fit_30, integral0=0.0)
x_fit_25 = solve_model(t_fine, a_fit_25, b_fit_25, m_fit_25, x0=x0_fit_25, integral0=0.0)

# Plot the results
plt.figure(figsize=(10, 6))

# Plot the original data for T=30
plt.scatter(data_time_30, data_x_30, label='Data (T=30)', color='red')

# Plot the original data for T=25
plt.scatter(data_time_25, data_x_25, label='Data (T=25)', color='green')

# Plot the fitted model for T=30
plt.plot(t_fine, x_fit_30, label='Fitted Model (T=30)', color='red')

# Plot the fitted model for T=25
plt.plot(t_fine, x_fit_25, label='Fitted Model (T=25)', color='green')

# Add labels and title
plt.xlabel('Time (h)')
plt.ylabel('x (g/L)')
plt.title('Fitting Integro-Differential Equation to Data (T=30 and T=25)')
plt.legend()
plt.grid()

# Show the plot
plt.tight_layout()
plt.show()

# Print fitted parameters
print(f"Fitted parameters for T=30: a = {a_fit_30:.4f}, b = {b_fit_30:.4f}, m = {m_fit_30:.4f}, x0 = {x0_fit_30:.4f}")
print(f"Fitted parameters for T=25: a = {a_fit_25:.4f}, b = {b_fit_25:.4f}, m = {m_fit_25:.4f}, x0 = {x0_fit_25:.4f}")

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp
from scipy.optimize import curve_fit

# Define the integro-differential equation model
def integro_differential_model(t, y, a, b, c, m):
    x = y[0]  # Current value of x
    integral = y[1]  # Current value of the integral
    dx_dt = a * x * 1 / (1 + c * np.exp(b * integral)) - m * x
    dintegral_dt = x  # The derivative of the integral is simply x
    return [dx_dt, dintegral_dt]

# Define a function to solve the integro-differential equation
def solve_model(t_eval, a, b, c, m, x0, integral0):
    t_span = (t_eval[0], t_eval[-1])
    y0 = [x0, integral0]  # Initial conditions: [x, integral]

    sol = solve_ivp(
        lambda t, y: integro_differential_model(t, y, a, b, c, m),
        t_span,
        y0,
        t_eval=t_eval,
        method='RK45'
    )
    return sol.y[0]  # Return only the population (x)

# Data for T=30
data_time_30 = np.array([0, 3, 6, 9, 12, 24, 27, 30, 33, 36, 48])
data_x_30 = np.array([0.36, 0.59, 0.85, 1.44, 2.60, 8.54, 10.82, 12.46, 14.81, 14.29, 10.47])

# Data for T=25
data_time_25 = np.array([0, 3, 6, 9, 12, 24, 27, 30, 33, 36, 48])
data_x_25 = np.array([0.35, 0.47, 0.88, 1.30, 2.29, 7.03, 10.62, 12.70, 14.33, 14.17, 11.49])

# Define a function for curve fitting
def fit_model(t, a, b, c, m, x0):
    return solve_model(t, a, b, c, m, x0=x0, integral0=0.0)

# Fit the model to T=30 data
popt_30, pcov_30 = curve_fit(
    lambda t, a, b, c, m, x0: fit_model(t, a, b, c, m, x0),
    data_time_30,
    data_x_30,
    p0=[0.4, 0.02, 0.5, 0.01, 0.36],  # Initial guess for a, b, c, m, x0
    bounds=(0, [1, 1, 2, 1, 1])  # Bounds for a, b, c, m, x0
)

# Fit the model to T=25 data
popt_25, pcov_25 = curve_fit(
    lambda t, a, b, c, m, x0: fit_model(t, a, b, c, m, x0),
    data_time_25,
    data_x_25,
    p0=[0.4, 0.02, 0.5, 0.01, 0.35],  # Initial guess for a, b, c, m, x0
    bounds=(0, [2, 1, 2, 1, 1])  # Bounds for a, b, c, m, x0
)

# Extract fitted parameters for T=30 and T=25
a_fit_30, b_fit_30, c_fit_30, m_fit_30, x0_fit_30 = popt_30
a_fit_25, b_fit_25, c_fit_25, m_fit_25, x0_fit_25 = popt_25

# Solve the model with fitted parameters
t_fine = np.linspace(0, 48, 500)
x_fit_30 = solve_model(t_fine, a_fit_30, b_fit_30, c_fit_30, m_fit_30, x0=x0_fit_30, integral0=0.0)
x_fit_25 = solve_model(t_fine, a_fit_25, b_fit_25, c_fit_25, m_fit_25, x0=x0_fit_25, integral0=0.0)

# Plot the results
plt.figure(figsize=(10, 6))

# Plot the original data for T=30
plt.scatter(data_time_30, data_x_30, label='Data (T=30)', color='red')

# Plot the original data for T=25
plt.scatter(data_time_25, data_x_25, label='Data (T=25)', color='green')

# Plot the fitted model for T=30
plt.plot(t_fine, x_fit_30, label='Fitted Model (T=30)', color='red')

# Plot the fitted model for T=25
plt.plot(t_fine, x_fit_25, label='Fitted Model (T=25)', color='green')

# Add labels and title
plt.xlabel('Time (h)')
plt.ylabel('x (g/L)')
plt.title('Fitting Integro-Differential Equation to Data (T=30 and T=25)')
plt.legend()
plt.grid()

# Show the plot
plt.tight_layout()
plt.show()

# Print fitted parameters
print(f"Fitted parameters for T=30: a = {a_fit_30:.4f}, b = {b_fit_30:.4f}, c = {c_fit_30:.4f}, m = {m_fit_30:.4f}, x0 = {x0_fit_30:.4f}")
print(f"Fitted parameters for T=25: a = {a_fit_25:.4f}, b = {b_fit_25:.4f}, c = {c_fit_25:.4f}, m = {m_fit_25:.4f}, x0 = {x0_fit_25:.4f}")

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

# Define the integro-differential equation models
def integro_differential_model_3_params(t, y, a, b, m):
    x = y[0]  # Current value of x
    integral = y[1]  # Current value of the integral
    dx_dt = a * x * np.exp(-b * integral) - m * x
    dintegral_dt = x  # The derivative of the integral is simply x
    return [dx_dt, dintegral_dt]

def integro_differential_model_4_params(t, y, a, b, c, m):
    x = y[0]  # Current value of x
    integral = y[1]  # Current value of the integral
    dx_dt = (
        a * x / (1 + c * np.exp(b * integral))
        - m * x
    )
    dintegral_dt = x  # The derivative of the integral is simply x
    return [dx_dt, dintegral_dt]

# Time span and initial conditions
t_span = (0, 15)
t_eval = np.linspace(*t_span, 500)
initial_conditions = [0.1, 0.0]  # Initial values for x and the integral

# Parameters for the models
params_3 = [(1.0, 0.5, 0.1), (1.2, 0.3, 0.2), (0.8, 0.7, 0.15)]  # (a, b, m)
params_4 = [
    (1.0, 0.5, 0.1, 0.1),
    (1.0, 0.5, 0.2, 0.1),
    (1.0, 0.5, 0.3, 0.1),
]  # (a, b, c, m)

# Solve the models
solutions_3 = [
    solve_ivp(
        integro_differential_model_3_params,
        t_span,
        initial_conditions,
        t_eval=t_eval,
        args=params,
    )
    for params in params_3
]

solutions_4 = [
    solve_ivp(
        integro_differential_model_4_params,
        t_span,
        initial_conditions,
        t_eval=t_eval,
        args=params,
    )
    for params in params_4
]

# Plot the results
fig, axes = plt.subplots(1, 2, figsize=(12, 6), sharey=True)

# Plot the 3-parameter model
for i, sol in enumerate(solutions_3):
    axes[0].plot(sol.t, sol.y[0], label=f"Set {i+1}")
axes[0].set_title("3-Parameter Model")
axes[0].set_xlabel("Time (t)")
axes[0].set_ylabel("x(t)")
axes[0].legend()

# Plot the 4-parameter model
for i, sol in enumerate(solutions_4):
    axes[1].plot(sol.t, sol.y[0], label=f"Set {i+1}")
axes[1].set_title("4-Parameter Model")
axes[1].set_xlabel("Time (t)")
axes[1].legend()

plt.tight_layout()
plt.show()